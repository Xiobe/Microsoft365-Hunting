# Offensive WMIC

To gather information on a Windows host we can abuse wmic. This can be done from the command line (cmd.exe) and PowerShell or for example python. The nice thing about WMIC enumeration is that you do not any special permissions to do this. 

Remember that the query does not have to be executed all at once, piece by piece will and stitching the information together is also a possibility.

From a defenders point of view is WMIC logging minimal and since it runs directly in memory, it leaves no traces on disk. WMI scripts can be deployed for administrative tasks on remote computers with other tooling like System Center Operations Manager (SCCM) or Windows Remote Management (WinRM).

Due to the small surface area for forensics and the built-in capabilities to do system administration, it is a very good post-exploitation tool to master. 

According to https://research.nccgroup.com/2022/03/10/microsoft-announces-the-wmic-command-is-being-retired-long-live-powershell Microsoft has announced no longer to develop wmic and it will be removed from Windows 11, 10, and server builds going forward. The WMI functionality will however still be available to system administrators via PowerShell.

## WMIC from the command line
Wmic is located as `C:\Windows\System32\wbem\WMIC.exe` (64-bit) or as `C:\Windows\SysWow64\wbem\WMIC.exe` (32-bit) on disk. You can copy the 64-bit wmic.exe from C:\Windows\System32\wbem\wmic.exe to for example C:\temp\wmic.exe and run your query. There is no check if the correct image got launched. 

### Detection by Microsoft Defender for Endpoints

#### Timeline on the endpoint
The execution of WMIC.exe gets tagged as MITRE ATT&CK technique `T1047: Windows Management Instrumentation` but doesn't alert. When the attacker puts a copy of wmic in `C:\temp` it is not more suspicious than a standard WMIC. This leads to 2 detection use cases.

##### UseCase: WMIC's image on disk is located at wrong location
We search for WMIC.exe images that have not been started from the default locations.
```
DeviceProcessEvents
| where FileName contains "wmic.exe"
| where FolderPath !in ("C:\\Windows\\System32\\wbem\\WMIC.exe","C:\\Windows\\SysWOW64\\wbem\\WMIC.exe")
```

##### UseCase: WMIC's image on disk has low global prevalance
We search for WMIC images that have a low global prevalence
```
DeviceProcessEvents
| where FileName contains "wmic.exe"
| invoke FileProfile("SHA256", 500)
| where GlobalPrevalence < 100
```


## WMIC from PowerShell
To run WMIC queries from PowerShell you use the `Get-WmiObject` cmdlet. For PowerShell to log anything you need to activate:
* Windows Advanced Audit Policies
* PowerShell Audit Logging

More info can be found at https://www.malwarearchaeology.com/cheat-sheets

Another important aspect is to configure the log rotation correctly. Using a GPO the log size should be increased too. Ideally the logs should be forwarded to a SIEM.

In order to collect event ID 4104, the Windows PowerShell Audit Policy should have the following policy:
* PowerShell version 5 should be installed (requires .NET 4.5 or later)
* Minimum log size of 1,204,000kb or larger
* The GPO must be set as:
  * ModuleLogging `Reg_DWord=1`
  * ModuleNames `Reg_Sz value=*`
  * ScriptBlockLogging `Reg_DWord=1`

PowerShell logs to 2 logs:
* Windows PowerShell (legacy)
* Applications and Services - Microsoft-Windows-PowerShell/Operational

The event IDs of interest are 4100, 4103, 4104. Any user running PowerShell will be interesting, the idea is to monitor the ScriptBlock for the following WMI-related cmdlets:
* `Get-WmiObject`
* `Invoke-WmiMethod`
* `Register-WmiEvent`
* `Remove-WmiObject`
* `Set-WmiInstance`

The following PowerShell CIM (common information model) cmdlets should also be monitored since they can serve as a replacement for older WMI cmdlets:
* `Export-BinaryMiLog`
* `Get-CimAssociatedInstance`
* `Get-CimClass`
* `Get-CimInstance`
* `Get-CimSession`
* `Import-BinaryMiLog`
* `Invoke-CimMethod`
* `New-CimMethod`
* `New-CimInstance`
* `New-CimSession`
* `New-CimSessionOption`
* `Register-CimIndicationEvent`
* `Remove-CimInstance`
* `Remove-CimSession`
* `Set-CimInstance`

## WMIC from Python
To run WMIC queries from Python you can use https://pypi.org/project/WMI/

## The WMIC enumeration queries
We list the WMIC queries here in PowerShell because it is 

### Enumerating the Host and Operating System information

```
Get-WmiObject -Class win32_computersystem -Property bootupstate,username,totalphysicalmemory,systemtype,domain,dnshostname,oemstringarray
```

This information will help the attacker figure out if he is in an emulated environment via the `OEMStringArray` and the `SystemFamily`. The `bootupstate` indicates if the system was booted in fail-safe mode.  The `domain` will indicate if the system is domain-joined, sandboxes are often not domain joined or joined to the wrong domain.

In the case that the number of logical processors is less than 4 and the RAM available below 2 Gigabyte, chances are that the machine is a virtual machine as well.

```
Get-WmiObject -Class win32_operatingsystem | fl *
```

The win32_operatingsystem might be useful for system enumeration too. When you see in the `caption` and `name` the value `evaluation` it will tell you that is is a sandbox too.

### Directory Listing
Listing the directories on a system is a fundamental operation in the reconnaissance of a system. The WMI has 2 classes that can be used for this:
* `Win32_Directory`
* `CIM_DataFile`

```
Get-WmiObject -Class win32_directory | select name
```

When you are looking for particular directories like snapshots or backups you can run something like

```
Get-WmiObject -Class win32_directory -filter 'name -like "%snapshot%"'
Get-WmiObject -Class win32_directory -filter 'name -like "%backup%"'
```

### AV Product Enumeration
WMI provides us a class AntivirusProduct that allows to enumerate the antivirus product. The `AntiVirusProduct` class is located under the `root\SecurityCenter2` namespace.

```
Get-WmiObject -NameSpace root\securitycenter2 -class antivirusproduct
```

The `productstate` tells you whether the product is enabled or disabled and whether the definitions are up-to-date or outdated. When you convert the productstate to hexadecimal you can convert the value to its status. For example 397312 to hex is 061000. When the last to characters are 00, it means the product is up-to-date and when the last two are 10, the product is out-of-date. When the middle two characters are 10 or 11 it seems the product is enabeled where as it is 00 or 01 the product seems to be disabled.

Known values are:
| Value | Hex | Product | State |
| --- | --- | --- | --- |
| 262144 | 040000 | AVG Internet Security 2012 | disabled and up-to-date |
| 266240 | 041000 | AVG Internet Security 2012 | enabled and up-to-date |
| 266256 | 041010 | AVG Internet Security 2012 | firewall enabled |
| 262160 | 040010 | AVG Internet Security 2012 | firewall disabled |
| 393472 | 060100 | Windows Defender | disabled and up-to-date |
| 397584 | 061110 | Windows Defender | enabled and out-of-date |
| 397568 | 061100 | Windows Defender | enabled and up-to-date |
| 397312 | 061000 | Microsoft Security Essentials | enabled and up-to-date |
| 393216 | 060000 | Microsoft Security Essentials | disabled and up-to-date |

### Service Enumeration
Service on Windows are similar to Unix daemons. They are processes with no UI, running in the background. The processes that are most interesting for an attacker are those that have been created by `SYSTEM` and have weak file permissions. The services created by `SYSTEM` are identified by the fact they are initiated by `LocalSystem` or `NT Authority\System`. 

```
Get-WMIObject -class win32_Service -filter 'startname="localsystem"' | select *
```

WMI also allows interacting with the services, it allows for:
* service creation
* service deletion
* service starting
* service stopping
* service resuming
* service updating
* ...

To get the list of the available methods available you do

```
Get-WmiObject -Class win32_service -list | select -ExpandProperty methods
```

An example of a malicious process creation would be:

```
cmd.exe /c "wmic /node:10.0.0.1" /user:"workgroup\administrator" /password:"myweakpassword" PROCESS CALL CREATE"cmd.exe /c C:\ProgramData\my.bat" >> C:\Windows\Temp\cnd45.tmp
```

In the example above the attacker has already gained access to the local admin on node 10.0.0.1 and launches remotely a payload for which the attacker will capture the output in a local temporary file. This will however create an event with ID 4688 in the security log of the remote system when commandline auditing is turned on. However, when the attacker simply calls wmic directly, which spawns a wmic console, there is only a trace of the process spawn of wmic. There is no further trace of the queries.

### Logged-on Users
In order to enumerate the logged-on users we need to look at 2 classes:
* `win32_loggedonuser`
* `win32_logonsession`

As the name indicates, `win32_loggedonuser` tells you about the users that are logged on where `win32_logonsession` tells you about the sessions these users have.

```
Get-WmiObject -Class win32_loggedonuser
```

The `win32_loggedonuser` returns the locally-unique identifier (LUID). Some of the LUIDs are predefined but most are randomly generated:
| LUID hexadecimal | LUID decimal| Account |
| --- | --- | --- |
| 0x3e7 | 999 | `SYSTEM` |
| 0x3e4 | 996 | `Network Service` |
| 0x3e5 | 997 | `Local Service` |

Each logged-on user defines it depends via the `Dependent` property.  We can match the list of logon IDs, the authentication type, start time and scope of every session using the `win32_logonsession` class:

```
Get-WmiObject -Class win32_logonsession | select authenticationpackage, logonid, starttime, scope
```

### Installed Patches
It is often useful to enumerate patches to see if you can exploit a vulnerability on the system as an attacker. WMI has a class called `Win32_QuickFixEngineering` that contains the information about the installed updates and patches:

```
Get-WmiObject -Class win32_quickfixengineering
```

### Eventlogs
The class `win32_ntlogevents` contains the eventlogs by the system. You can query like

```
Get-WmiObject -Class win32_ntlogevent
```

Each log entry carries details and the severity is indicated by the field `Type`. There are 5 different types:
| Value | Description |
| --- | --- |
| 1 | Error |
| 2 | Warning |
| 4 | Information |
| 8 | Security Audit Success |
| 16 | Security Audit Failure |

### Shares
The `Win32_Share` class represents a shared resource on a system. A share can be:
* a disk drive
* a printer
* interprocess communication (IPC)
* ...

To enumerate all shares you do

```
Get-WmiObject -class win32_share | select type, name, allowmaximum, description, scope
```

| Type | Description |
| --- | --- |
| 0 | Disk Drive |
| 1 | Print Queue |
| 2 | Device |
| 3 | IPC |
| 2147483648 | Disk Drive Admin |
| 2147483649 | Print Queue Admin |
| 2147483650 | Device Admin |
| 2147483651 | IPC Admin |

The `AllowMaximum` is a boolean property to indicate whether concurrent access to the resource has been allowed or restricted. When set to True, there is no restriction. When set to False there is a restriction and thus a possible indicator that the share contains some sensitive information or have more intensive monitoring.

WMI allows also to create, update and delete shares. The methods available via WMI can be obtained with

```
Get-WmiObject -Class win32_share -list | select -ExpandProperty
```

### Network information enumeration
Network information can be obtained via the `win32_IP4RouteTable` which gives an overview of the configuration of the network NICs on the system.

```
Get-WmiObject -Class win32_ip4routeable
```

The `win32_networkadapter` will allow you to determine if virtualization took place at the NIC level.

```
Get-WmiObject -Class win32_networkadapter -filter 'name like "%vmware%"'
Get-WmiObject -Class win32_networkadapter -filter 'manufacturer like "%vmware%"'
```

### User Account Enumeration
The user accounts on a system can be enumerated via

```
Get-WmiObject -Class win32_useraccount
```

Common User Accouns are:
| Account | Description | SID ends with |
| --- | --- | --- |
| Administrator | Your local administrator | 500 |
| DefaultAccount | Your local default account | 503 |
| Guest | Your local guest account | 501 |
| WDAGUtilityAccount | Windows Defender | 504 |

A domain-joined box or the domain controller itself will have also different ones. For example you will see `krbtgt` on the domain controller,  `sqladmin` on a MSSQL server and `webadmin` on an IIS server.

### User Group Enumeration
The user groups are enumerated via

```
Get-WmiObject -Class win32_group
```

Local groups start with the hostname followed by a backslash and the username, where the domain-joined systems will also show you the current domain groups, the trusted domain groups and the trusted forest groups.

### Shadow Copies
When you have sufficient permissions on a system as attacker you can create a shadow copy and try to extract the secrets from these shadow copies. The shadow copy is a Windows technology that allows you to make snapshots from computer files and volumes even when they are in use.

To interact with shadow copies you have 2 methods

```
Get-WmiObject -Class win32_shadowcopy | list -ExpandProperty methods
```

To create a shadow copy the attacker runs the following code to specify a volume and a context for the copy creation:

```
(Get-WmiObject -Class win32_shadowcopy -List).create("C:\", "ClientAccessible")
```

Next, to facilitate easy access from the local explorer, the attacker can create a symlink:

```
$link = (Get-WmiObject -Class win32_shadowcopy).deviceobject + "/"
cmd /c mklink C:\shadowcopy "$link"
```

Once the shadow copu is ready to use a tool like Invoke-SessionGopher.ps1 (https://github.com/samratashok/nishang/blob/master/Gather/Invoke-SessionGopher.ps1) can be used to yield information from:
* PuTTY
* WinSCP
* FileZilla
* SuperPuTTY
* RDP
* ...
